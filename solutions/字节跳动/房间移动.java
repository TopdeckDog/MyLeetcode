package 字节跳动;

import java.util.*;

/*
存在n+1个房间，每个房间依次为房间1 2 3...i，每个房间都存在一个传送门，i房间的传送门可以把人传送到房间pi(1<=pi<=i),现在路人甲从房间1开始出发(当前房间1即第一次访问)，每次移动他有两种移动策略：
    A. 如果访问过当前房间 i 偶数次，那么下一次移动到房间i+1；
    B. 如果访问过当前房间 i 奇数次，那么移动到房间pi；
现在路人甲想知道移动到房间n+1一共需要多少次移动；

输入描述:
第一行包括一个数字n(30%数据1<=n<=100，100%数据 1<=n<=1000)，表示房间的数量，接下来一行存在n个数字 pi(1<=pi<=i), pi表示从房间i可以传送到房间pi。

输出描述:
输出一行数字，表示最终移动的次数，最终结果需要对1000000007 (10e9 + 7) 取模。

输入例子1:
2
1 2

输出例子1:
4

例子说明1:
开始从房间1 只访问一次所以只能跳到p1即 房间1， 之后采用策略A跳到房间2，房间2这时访问了一次因此采用策略B跳到房间2，之后采用策略A跳到房间3，因此到达房间3需要 4 步操作。
 */

public class 房间移动 {
    // 思路:动态规划,状态转移方程dp[i+1] = dp[i] + 1 + dp[pi~i] + 1
    // 就是说要到i+1号房,必须到i号房2次,到i-1号房4次,到i-2号房8次,以此类推,每到i+1号房时,前面的房间都要从奇数开始
    // 那么dp[pi~i] = dp[i] - dp[pi],故dp[i+1] = 2dp[i] + 2 - dp[pi]
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] p = new int[n];
        for (int i = 0; i < n; i++) {
            p[i] = sc.nextInt() - 1;
        }
        int[] dp = new int[n+1];
        Arrays.fill(dp, 0);
        for (int i = 1; i <= n; i++) {
            dp[i] = 2 * dp[i-1] + 2 - dp[p[i-1]];
        }
        System.out.println(dp[n]);
    }
}
